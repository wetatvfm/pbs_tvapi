<?php
/**
 * @file
 * PBS TV API module.
 */


 /**
  * Include inc files
  */
module_load_include('inc', 'pbs_tvapi', 'blocks');
module_load_include('inc', 'pbs_tvapi', 'theme');


/**
 * Implements hook_permission().
 */
function pbs_tvapi_permission() {
  return array(
    'administer tvapi' => array(
      'title' => t('Administer PBS TV Schedules API settings'),
    ),
  );
}

/**
 * Implements hook_menu().
 * @see menu_example()
 */
function pbs_tvapi_menu() {

  // This is the minimum information you can provide for a menu item. This menu
  // item will be created in the default menu, usually Navigation.
  $items['pbs/tvapi'] = array(
    'title' => 'TV Schedules API',
    'page callback' => 'pbs_tvapi_description',
    'access callback' => TRUE,
    'expanded' => TRUE,
  );

  $items['schedule'] = array(
    'title' => 'Schedule',
    'page callback' => 'pbs_tvapi_dailyschedules',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['schedule/%'] = array(
    'title' => 'Schedule',
    'page callback' => 'pbs_tvapi_dailyschedules',
    'page arguments' => array(1, 2, 3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  // path with autocomplete function for tv series
  $items['tvseries/autocomplete'] = array(
    'title' => 'Autocomplete for tv series',
    'page callback' => 'pbs_tvapi_tvseries_autocomplete',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK
    );

  $items['admin/config/services/tvschedule_api'] = array(
    'title' => 'PBS TV Schedules API',
    'description' => 'Manage settings for the PBS TV Schedules API',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pbs_tvapi_admin_site_settings'),
    'access arguments' => array('administer tv_api'),
    'file' => 'pbs_tvapi.admin.inc',
  );

  $items['admin/config/services/tvschedule_api/test'] = array(
    'title' => 'PBS TV Schedules API Test Page',
    'description' => 'Test the results from PBS TV Schedules API',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pbs_tvapi_admin_tests'),
    'access arguments' => array('administer tv_api'),
    'file' => 'pbs_tvapi.admin.inc',
  );
  return $items;
}

/**
 * Gets configuration settings.
 *
 * @return array
 *   Associative array of config settings (api_key, callsign).
 */
function pbs_tvapi_get_config() {
  $config = &drupal_static(__FUNCTION__);

  if (!isset($config)) {
    $config = array(
      'api_key' => variable_get('pbs_tvapi_key'),
      'callsign' => variable_get('pbs_tvapi_callsign'),
    );
  }

  return $config;
}


/**
 * Constructs a descriptive page.
 *
 * Our menu maps this function to the path 'pbs/tvapi'.
 *
 */
function pbs_tvapi_description() {
  return array('#markup' => t('The PBS TV API provides television schedule data. The <a href="@series_link">series page</a> renders an XML formatted list of series currently in our schedule.', array('@series_link' => url('pbs/tvapi/series', array('absolute' => TRUE)))));
}

/*
 * Basic API call
 * @method = the method being called
 * @params = a string containing the parameter
 */
function pbs_tvapi_call2($method, $params = NULL) {
    $baseurl = 'http://services.pbs.org/tvss/';

    // get api key and callsign
    $config = pbs_tvapi_get_config();
    $api_key = (empty($api_key)) ? $config['api_key'] : $api_key;
    $callsign = (empty($callsign)) ? $config['callsign'] : $callsign;

    // callsign should be all lower case
    $callsign = strtolower($callsign);

    $header = 'X-PBSAUTH: ' . $api_key;

    $opts = array(
      'http' => array(
        'method' => 'GET',
        'header' => $header,
        'timeout' => 15
      )
    );
    $context = stream_context_create($opts);

    // construct the API request
    $url = $baseurl . $callsign . '/' . $method . '/' . $params . '/';

    // query the API
    $results = file_get_contents($url, FALSE, $context);
    //dpm(array($url, $results), 'file_get_contents() results');
    //dpm($http_response_header, 'file_get_contents() response');

    // decode JSON
    if (!empty($results)) {
      $scheduledata = json_decode($results, TRUE);

      // if there's an issue, display the error
      // otherwise return the results
      if (is_null($scheduledata)) {
        //watchdog('pbs_tvapi', check_plain($results), NULL, WATCHDOG_WARNING);
        //print 'PBS Error: ' . check_plain($results);
        return NULL;
      }
      else {
        return $scheduledata;
      }
    }
    else {
      return NULL;
    }
}

/**
 * Get today's listings
 */
function pbs_tvapi_gettoday() {

  $listings = &drupal_static(__FUNCTION__);
  if (!isset($listings)) {
    if ($cache = cache_get('pbs_tvapi_gettoday_data') && !empty($cache->data)) {
      $listings = $cache->data;
    }
    else {

      // get the listings
      $method = 'today';

      $raw_listings = pbs_tvapi_call2($method);
      $listings = array();
      if (!empty($raw_listings)) {
        // remove analog listings and reindex using shortname as key
        foreach ($raw_listings['feeds'] as $i => $listing) {
          if (!empty($listing['digital_channel'])) {
            $listings[$listing['short_name']] = $listing;
          }
        }
        cache_set('pbs_tvapi_gettoday_data', $listings, 'cache');
      }
    }
  }
  return $listings;
}

/**
 * Jumping through hoops since there's no Title ID in V2 of the API
 */
function pbs_tvapi_getindex($episode = array()) {
  $ep_id = '';
  if (isset($episode['program_id']) && !empty($episode['program_id'])) {
    $ep_id = $episode['program_id'];
  }
  elseif (isset($episode['show_id']) && !empty($episode['show_id'])) {
    $ep_id = $episode['show_id'];
  }

  return $ep_id;
}



/**
 * DAILY SCHEDULE FUNCTIONS
 */

/**
 * Form to navigate daily schedule
 */
function pbs_tvapi_dailyschedule_form($form, &$form_state) {

  // set up channel options
  $channeloptions = array();
  $channeloptions['all'] = 'All';
  $channeloptions['WETADT4'] = 'WETA TV 26';
  $channeloptions['WETADT'] = 'WETA HD';
  $channeloptions['WETADT2'] = 'WETA UK';
  $channeloptions['WETADT3'] = 'WETA KIDS';

  // set date options
  $date = strtotime('now -1 week');
  $end = strtotime('now +13 days');
  $today = strtotime('now');

  $dateoptions = array();

  while ($date <= $end) {
    $dateoptions[date('Ymd', $date)] = date('l, F j', $date);
    $date = strtotime('+1 day', $date);

  }

  // set up time options
  $timeoptions = array();

  foreach (range(0, 23) as $fullhour) {
    $parthour = $fullhour > 12 ? $fullhour - 12 : $fullhour;
    if ($parthour == 0) {
      $parthour = 12;
    }
    $parthour = $parthour . ':00';
    $parthour .= $fullhour > 11 ? ' PM' : ' AM';
    $timeoptions[$fullhour] = $parthour;
  }

  $selectedchannel = 'all';
  $selected = date('Ymd', $today);
  $selectedtime = date('H', $today);
  if ($selectedtime < 10) {
    $selectedtime = '0' . $selectedtime;
  }

  $arg1 = arg(1);
  $arg2 = arg(2);
  $arg3 = arg(3);
  $channelkeys = array_keys($channeloptions);
  $datekeys = array_keys($dateoptions);
  $timekeys = array_keys($timeoptions);

  if (!empty($arg1) && !empty($arg2) && in_array(arg(1), $channelkeys) && in_array(arg(2), $datekeys) && in_array(arg(3), $timekeys)) {
    $selectedchannel = arg(1);
    $selected = arg(2);
    $selectedtime = arg(3);
  }



  // add class to form
  $form['#attributes']['class'] = 'schdform';

  // build date select element
  $form['date_options'] = array(
    '#type' => 'value',
    '#value' => $dateoptions,
  );
  $form['date'] = array(
    '#type' => 'select',
    '#title' => t('Date'),
    '#name' => 'date',
    '#id' => 'datepick',
    '#field_prefix' => '<div class="select_menu_wrap select_menu_wrap_date">',
    '#field_suffix' => '</div>',
    '#options' => $form['date_options']['#value'],
    '#default_value' => $selected,
  );

  // build time select element
  $form['time_options'] = array(
    '#type' => 'value',
    '#value' => $timeoptions,
  );

  $form['time'] = array(
    '#type' => 'select',
    '#title' => t('Time'),
    '#name' => 'time',
    '#id' => 'timepick',
    '#field_prefix' => '<div class="select_menu_wrap">',
    '#field_suffix' => '</div>',
    '#options' => $form['time_options']['#value'],
    '#default_value' => $selectedtime,
  );

  // build channel select element
  $form['channel_options'] = array(
    '#type' => 'value',
    '#value' => $channeloptions,
  );

  $form['channel'] = array(
    '#type' => 'select',
    '#title' => t('Channel'),
    '#name' => 'channel',
    '#id' => 'channelpick',
    '#field_prefix' => '<div class="select_menu_wrap">',
    '#field_suffix' => '</div>',
    '#options' => $form['channel_options']['#value'],
    '#default_value' => $selectedchannel,
  );

  // build submit button
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Go'),
    '#prefix' => '<div class="form-item">',
    '#suffix' => '</div>',
    '#attributes' => array('class' => array('button')),
  );

  return $form;

}

/**
 * Submit handler for daily schedule form
 */

function pbs_tvapi_dailyschedule_form_submit($form, &$form_state) {
  $form_state['redirect'] = 'schedule/' . $form_state['input']['channel'] . '/' . $form_state['input']['date'] . '/' . $form_state['input']['time'];
}


/**
 * Pulls the daily schedule based on the date and time arguments passed in the URL.
 *
 * This callback is mapped to the path 'schedule/%/%/%'. If no arguments,
 * it defaults to today and now.
 *
 */
function pbs_tvapi_dailyschedules($thischannel = 'all', $date = NULL, $time = NULL) {

  // Make sure you don't trust the URL to be safe! Always check for exploits.
  $channeloptions = array('all', 'WETADT4', 'WETADT', 'WETADT2', 'WETADT3');
  if (!in_array($thischannel, $channeloptions)) {
    $thischannel = 'all';
  }

  if (!is_numeric($date) || (is_numeric($date) && drupal_strlen($date) != 8)) {
    $date = date('Ymd', time());
  }


  if (!is_numeric($time) || (is_numeric($time) && $time > 24)) {
    $date = date('Ymd', time());
    $time = date('H', time());
  }

  // get the page title
  $title = drupal_get_title();
  // alter the page title to match the schedule's display date
  $today = date('Ymd', time());
  if ($today != $date) {
    $title = $title . ': ' . date('F j, Y', strtotime($date));
    drupal_set_title($title);
  }

  // set our window of available dates
  $windowopen = strtotime('now -1 week midnight');
  $windowclose = strtotime('now +2 weeks');
  $inputdate = strtotime($date);

  $error = '';
  // if we're NOT within the window:
  if (($inputdate <= $windowopen) || ($inputdate >= $windowclose)) {
    $displaydate = date('F j, Y', $inputdate);
    drupal_set_message(t('Schedule data for ' . $displaydate . ' is not currently available.'), 'error');
    $date = date('Ymd', time());
    $time = date('H', time());
  }

  // determine if we're in Daylight Savings and set offset accordingly
  // so the start and end times will be correct
  $date_time = strtotime(date('Y-m-d', strtotime($date)) . 'T' . $time . ':00:00');
  $offset = '05:00';
  $offset_seconds = 18000;
  $dst = date('I', $date_time);
  if ($dst == 1) {
    $offset = '04:00';
    $offset_seconds = 14400;
  }

  // set the start and end times
  $hour = $time . ':00:00-' . $offset;
  $start = strtotime(date('Y-m-d', strtotime($date)) . 'T' . $hour);
  // end 24 hours later.
  $end = $start + 86400;

  $apidate = $start;
  $method = 'day';

  $listings = array();

  // loop through two days worth of schedule to get a full 24 hours
  for ($days = 1; $days <= 2; $days++) {
    // pick a day
    $thisday = date('Ymd', $apidate);

    // call the api
    $scheduledata = pbs_tvapi_call2($method, $thisday);

    // loop through the response
    foreach ($scheduledata['feeds'] as $i => $feed) {
      if (!empty($feed['digital_channel'])) {
        $feed['listings'] = pbs_tvapi_listings($feed['listings'], $thisday);

        if (empty($listings[$feed['short_name']])) {
          $listings[$feed['short_name']] = $feed;
        }
        else {
          // add 2nd day listings to the array
          $listings[$feed['short_name']]['listings'] = array_merge($listings[$feed['short_name']]['listings'], $feed['listings']);
        }
      }

    }

    // increment a day
    $apidate = strtotime($thisday . ' +1 day');
  }

  // filter out only the episodes in the search window
  $listings = pbs_tvapi_filter_episodes($listings, $start, $end);

  // apply any other listings hooks
  drupal_alter(array('pbs_tvapi_listings'), $listings);

  // get series information
  $series = pbs_tvapi_get_series();

  $schedule_display = '';

  // all channels
  if ($thischannel == 'all') {
    // Our primary channel (TV 26) is technically WETADT4, so comes last in
    // the array.  We need to reorder the channels so TV 26 is first.
    asort($listings);
    $count = count($listings);
    $tv26 = array_slice($listings, $offset = $count - 1, $preserve_keys = TRUE);
    $listings = $tv26 + $listings;

    // set up all the dates needed for the grid
    $setup = pbs_tvapi_grid_setup($date, $time);
    $dates = $setup['dates'];
    $times = $setup['times'];


    // Insert necessary placeholders at the beginning and end of the grid so
    // it will line up correctly.
    $listings = pbs_tvapi_grid_fix($listings, $dates);

    // send to theme for display
    $variables = array('listings' => $listings, 'dates' => $dates, 'times' => $times, 'series' => $series);
    $schedule_display = theme_schedule_grid($variables);

  }

  else {
    $channelepisodes = $listings[$thischannel]['episodes'];

    foreach($channelepisodes as $i => &$episode) {

      // format the start and end times for display
      $episode['start_formatted'] = date('g:i A', $episode['starttime']);
      $episode['end_formatted'] = date('g:i A', $episode['endtime']);
      $episode['start_formatted_details'] = date('F j, Y', $episode['starttime']) . ' at ' . date('g:i a', $episode['starttime']);

      // safety first
      $episode['title'] = check_plain($episode['title']);
      $episode['eptitle'] = check_plain($episode['eptitle']);
    }

    $channelname = $listings[$thischannel]['full_name'];

    $variables = array('episodes' => $channelepisodes, 'channel' => $channelname, 'series' => $series);

    $schedule_display = theme_single_channel_grid($variables);
    $error = '';
  }

  return array('#markup' => $schedule_display);
}

/**
 * Edit listings response.
 *
 * @param $listings: Listings from API
 * @param $thisday: The day the listings are for
 */
function pbs_tvapi_listings($listings, $thisday) {

  foreach ($listings as $n => $listing) {
    // add a full start date key to the array
    $fullstart = strtotime($thisday . ' ' . $listing['start_time']);
    $fullstart_human = date('Y-m-d g:i a', $fullstart);
    $listings[$n]['full_start'] = $fullstart;

    // add a unique title key to the array
    $listings[$n]['title_key'] = pbs_tvapi_getindex($listing);

  }

  return $listings;
}

/**
 * Filter episodes to just those required by the episodes grid.
 *
 * @param $listings: array returned from the API cal
 * @param $start: timestamp for the start of the grid window
 * @param $end: timestamp for the end of the grd window
 *
 */
function pbs_tvapi_filter_episodes($listings, $start, $end) {
  foreach ($listings as $channel) {
    $filtered_episodes = array();

    foreach ($channel['listings'] as $i => $this_listing) {
      // if the listing is within the window, add it to the array
      if ($this_listing['full_start'] >= $start && $this_listing['full_start'] < $end) {

        // add listing to array
        $filtered_episodes[] = $this_listing;
      }
    }

    // trim the episodes array to only items needed for display
    $listings[$channel['short_name']]['episodes'] = pbs_tvapi_episodes_display($filtered_episodes);
    unset($listings[$channel['short_name']]['listings']); // clean up

  }
  return $listings;
}



/**
 * Set up dates and times for the daily grid and account for Daylight Savings
 * shenanigans.
 *
 * @param $date: The start date of the grid
 * @param $time: The start time of the grid
 *
 */
function pbs_tvapi_grid_setup($date, $time) {
  $setup = array();

  $dates = array();
  $dates['grid']['start_formatted'] = date('Y-m-d', strtotime($date)) . 'T' . $time . ':00:00 America/New_York';
  $dates['grid']['start_stamp'] = strtotime($dates['grid']['start_formatted']);
  $dates['grid']['end_stamp'] = strtotime($dates['grid']['start_formatted'] . '+ 1 day');

  // Account for Daylight Savings Fall Back 2015

  // wackiness starts at 2am the night before and ends at 1am the day of
  $ds_start = strtotime('First Sunday Of November ' . date('Y') . ' 02:00:00 -1 day');
  $ds_end = strtotime('First Sunday Of November ' . date('Y') . ' 01:00:00');

  $ds = FALSE;
  if ($dates['grid']['start_stamp'] >= $ds_start  && $dates['grid']['start_stamp'] <= $ds_end) {
    $ds = TRUE;
  }

  // we need to move the end of the grid an hour earlier, since there are two 2ams.
  if ($ds) {
    $dates['grid']['end_stamp'] = strtotime($dates['grid']['start_formatted'] . '+ 23 hours');
  }

  // Account for Daylight Savings Spring Forward
  $ds_spring = FALSE;
  // wackiness starts at 3am the night before and ends at 1am
  $ds_spring_start = strtotime('Second Sunday Of March ' . date('Y') . ' 03:00:00 -1 day');
  $ds_spring_end = strtotime('Second Sunday Of March ' . date('Y') . ' 01:00:00');



  if ($dates['grid']['start_stamp'] >= $ds_spring_start  && $dates['grid']['start_stamp'] <= $ds_spring_end) {
    $ds_spring = TRUE;
  }

  // we need to move the end of the grid an hour later, since we're losing 2am
  if ($ds_spring) {
    $dates['grid']['end_stamp'] = strtotime($dates['grid']['start_formatted'] . '+ 25 hours');
  }

  $dates['grid']['end_formatted'] = date('Y-m-d', $dates['grid']['end_stamp']) . 'T' . $time . ':00:00 America/New_York';

  $dates['day'] = date('D', strtotime($date));
  $dates['menu_date'] = date('M j', strtotime($date));

  $dates['prev'] = date('Ymd', strtotime($date . '- 1 day'));
  $dates['next'] = date('Ymd', strtotime($date . '+ 1 day'));

  $setup['dates'] = $dates;

  // set up time options
  $timesegments = array();
  $after = array();
  $before = array();

  $start = $time;

  // build time headers in half hour increments
  foreach (range(0, 23) as $fullhour) {
    $parthour = $fullhour > 12 ? $fullhour - 12 : $fullhour;
    if ($parthour == 0) {
      $parthour = 12;
    }
    $halfhour = $parthour . ':30';
    $parthour = $parthour . ':00';

    $parthour .= $fullhour > 11 ? ' PM' : ' AM';
    $halfhour .= $fullhour > 11 ? ' PM' : ' AM';
    if ($fullhour < $start) {
      //need to move these hours to the end
      $after[$fullhour] = $parthour;
      $after[$fullhour . '.5'] = $halfhour;
    }
    else {
      $before[$fullhour] = $parthour;
      $before[$fullhour . '.5'] = $halfhour;
    }
  }
  // put the list back together
  $timesegments = $before += $after;

  // Account for Daylight Savings Fall Back
  if ($ds && $dates['grid']['start_stamp'] != $ds_end) {

    // create an extra 1am and 1:30am to account for daylight savings
    $ds_segments = array('1.6' => '1:00 AM', '1.7' => '1:30 AM');

    // figure out where the extra 1 am should go
    $ds_pos = array_search('1.5', array_keys($timesegments));

    // split the array, dropping the final two items
    $segments_before = array_slice($timesegments, 0, $ds_pos +1, TRUE);

    $segments_after = array_slice($timesegments, $ds_pos + 1, -2, TRUE);


    // put the array back together again
    $timesegments = $segments_before += $ds_segments += $segments_after;

  }

  // Account for Daylight Savings Spring Forward
  if ($ds_spring) {
    // remove 2am and 2:30am to account for daylight savings
    unset($timesegments['2']);
    unset($timesegments['2.5']);
  }


  $times = array('start' => $time, 'segments' => $timesegments);

  $setup['times'] = $times;

  return $setup;
}

/**
 * Fix the grid display by inserting the necessary placeholder
 *
 * @param $listings: the listings array
 * @param $dates: the dates for the grid
 */
function pbs_tvapi_grid_fix($listings, $dates) {
  foreach ($listings as $i => &$channel) {
    if (!empty($channel['episodes'])) {
      $episodes = $channel['episodes'];
      $blank_placeholder = array_fill_keys(array_keys($episodes[0]), NULL);
      // if the first episode doesn't line up with the beginning
      // of the grid, insert a blank placeholder at the top of the array
      if (isset($episodes[0]['starttime'])) {
        $starttime = $episodes[0]['starttime'];
        if ($starttime != $dates['grid']['start_stamp']) {
          $difference = ($starttime - $dates['grid']['start_stamp'])/60;

          $placeholder = $blank_placeholder;
          $placeholder['duration'] = $difference;
          $placeholder['starttime'] = $dates['grid']['start_stamp'];
          $placeholder['endtime'] = $episodes[0]['starttime'];

          array_unshift($episodes, $placeholder);
          $channel['episodes'] = $episodes;

        }
      }
      // if the last episode doesn't line up with the end
      // of the grid, insert a blank placeholder at the end of the array
      $total_eps = count($episodes);
      if ($total_eps > 0) {
        $last_ep = $episodes[$total_eps - 1];
        $endtime = $last_ep['endtime'];
        if ($endtime < $dates['grid']['end_stamp']) {
          $difference  = ($dates['grid']['end_stamp'] - $endtime)/60;

          $placeholder = $blank_placeholder;
          $placeholder['duration'] = $difference;
          $placeholder['starttime'] = $last_ep['endtime'];
          $placeholder['endtime'] = $dates['grid']['end_stamp'];

          $episodes[] = $placeholder;
          $channel['episodes'] = $episodes;
        }
      }

      // if the grid start equals the Daylight Savings Fall Back
      // remove the first two items and insert a placeholder
      if ($dates['grid']['start_stamp'] == $ds_end) {
        $episodes = array_slice($episodes, 2, NULL);
        $starttime = $episodes[0]['starttime'];
        if ($starttime != $dates['grid']['start_stamp']) {
          $difference = ($starttime - $dates['grid']['start_stamp'])/60 - 60;

          $placeholder = $blank_placeholder;
          $placeholder['duration'] = $difference;
          $placeholder['starttime'] = $dates['grid']['start_stamp'];
          $placeholder['endtime'] = $episodes[0]['starttime'];

          array_unshift($episodes, $placeholder);
        }

        $channel['episodes'] = $episodes;
      }

      foreach($channel['episodes'] as $i => &$episode) {
        if ($ds_spring) {
          $episode_start_corrected = $episode['starttime'] + 3600;
          if ($episode_start_corrected >= $dates['grid']['end_stamp']) {
            unset($channel['episodes'][$i]);
          }


        }

        // pass along channel name
        $episode['channel'] = $channel['full_name'];

        // width of grid cell
        $episode['width'] = ($episode['duration'] * 4) - 1;

        // format the start and end times for display
        $episode['start_formatted'] = date('g:i A', $episode['starttime']);
        $episode['end_formatted'] = date('g:i A', $episode['endtime']);
        $episode['start_formatted_details'] = date('F j, Y', $episode['starttime']) . ' at ' . date('g:i a', $episode['starttime']);

        // safety first
        $episode['title'] = check_plain($episode['title']);
        $episode['eptitle'] = check_plain($episode['eptitle']);

        // unique id for calling modal details popup
        $episode['detail_id'] = $channel['short_name'] . '-' . $episode['starttime'];

        // if the episode doesn't start on the hour or half-hour
        // insert a note with the correct start time
        $minutes = date('i', $episode['starttime']);
        $episode['startnote'] = FALSE;
        if ($minutes != '00' && $minutes != '30') {
          $episode['startnote'] = TRUE;
        }

        // if this is the first episode not during the Daylight Savings Fall
        // Back window, width needs to be set from the grid start, not the
        // episode start
        if ($i == 0 && $dates['grid']['start_stamp'] != $ds_end) {
          $episode['width'] = ((($episode['endtime'] - $dates['grid']['start_stamp']) / 60) * 4) - 1;
        }
        // if this is the last episode, width needs to be set from the
        // grid end, not the episode end
        if ($i == $total_eps - 1) {
          $episode['width'] = ((($dates['grid']['end_stamp'] - $episode['starttime']) / 60) * 4) - 1;
        }
      }
    }
  }

  return $listings;

}


/**
 * Database query to get series info to match against tv schedule data
 *
 * Needed in order to form links to series nodes
 */
function pbs_tvapi_get_series() {
  $series = &drupal_static(__FUNCTION__);
  if (!isset($series)) {
    if ($cache = cache_get('pbs_tvapi_series_data')) {
      $series = $cache->data;
    }
    else {
      // Get series information from db
      $result = db_query('SELECT n.nid, f.field_title_id_value
      FROM {node} n LEFT JOIN {field_data_field_title_id} f ON n.nid = f.entity_id WHERE n.type = :type', array(':type' => 'tv_series'));

      // build series array to reference later
      $series = array();
      foreach ($result as $record) {
        $series[$record->field_title_id_value] = $record->nid;
      }
      cache_set('pbs_tvapi_series_data', $series, 'cache', CACHE_TEMPORARY);
    }
  }

  return $series;
}


/**
 * Loop to set up display of television episodes
 *
 */
function pbs_tvapi_episodes_display($episodes) {
  $variables = array();
  $delta = 0;

  foreach ($episodes as $episode) {
    // for now, make sure we exclude v1 calls
    if (empty($episode['feed_id'])) {
    $title = $episode['title'];

    $variables[$delta]['title'] = $title;

    $eptitle = '';
    if (!empty($episode['episode_title'])) {
      $eptitle = $episode['episode_title'];
    }

    $variables[$delta]['eptitle'] = $eptitle;

    $duration = $episode['minutes'];
    $variables[$delta]['duration'] = $duration;

    $starttime = $episode['full_start'];
    $endtime = $starttime + ($duration * 60);

    $variables[$delta]['starttime'] = $starttime;
    $variables[$delta]['endtime'] = $endtime;

    $variables[$delta]['program_id'] = '';
    if (!empty($episode['program_id'])) {
      $variables[$delta]['program_id'] = $episode['program_id'];
    }
    $variables[$delta]['show_id'] = '';
    if (!empty($episode['show_id'])) {
      $variables[$delta]['show_id'] = $episode['show_id'];
    }

    $variables[$delta]['title_key'] = '';
    if (!empty($episode['title_key'])) {
      $variables[$delta]['title_key'] = $episode['title_key'];
    }

    $variables[$delta]['promo_id'] = '';
    if (!empty($episode['promo_id'])) {
      $variables[$delta]['promo_id'] = $episode['promo_id'];
    }

    $variables[$delta]['youtube_id'] = '';
    if (!empty($episode['youtube_id'])) {
      $variables[$delta]['youtube_id'] = $episode['youtube_id'];
    }


    $variables[$delta]['promo_thumbnail'] = '';
    if (!empty($episode['promo_thumbnail'])) {
      $variables[$delta]['promo_thumbnail'] = $episode['promo_thumbnail'];
    }

    $variables[$delta]['description'] = '';
    if (!empty($episode['description'])) {
      $variables[$delta]['description'] = $episode['description'];
    }

    $variables[$delta]['episode_description'] = '';
    if (!empty($episode['episode_description'])) {
      $variables[$delta]['episode_description'] = $episode['episode_description'];
    }

    $variables[$delta]['special_warnings'] = '';
    if (!empty($episode['special_warnings'])) {
      $variables[$delta]['special_warnings'] = $episode['special_warnings'];
    }


    $delta++;
  }
  }

  return $variables;
}


/**
 * END DAILY SCHEDULE FUNCTIONS
 */

/**
 * BEGIN WHAT'S ON FUNCTIONS
 */

/**
 * What's On Now widget
 *
 * Expects a feed ID to determine the channel
 */
function pbs_tvapi_onnow($channel) {

  // Get YouTube Promo ids and put them in an array for later use
  $promos = pbs_tvapi_get_promos();

  // Get series information from db and put them in an array for later use
  $series = pbs_tvapi_get_series();


  $date = date('Y-m-d', time());
  $hour = date('H', time());

  $start = time();

  $method = 'day';
  $apidate = $start;

  $channels = '';
  // loop through two days worth of schedule to get a full 24 hours
  for ($days = 1; $days <= 2; $days++) {
    // pick a day
    $thisday = date('Ymd', $apidate);

    $scheduledata = pbs_tvapi_call2($method, $thisday);

    // loop through the response
    foreach ($scheduledata['feeds'] as $i => $feed) {

      if (!empty($feed['digital_channel'])) {
          foreach ($feed['listings'] as $n => $listing) {
            // add a full date to the array
            $fullstart = strtotime($thisday . ' ' . $listing['start_time']);
            $fullstart_human = date('Y-m-d g:i a', $fullstart);
            $feed['listings'][$n]['full_start'] = $fullstart;
          }

        if (empty($channels[$feed['short_name']])) {
          $channels[$feed['short_name']] = $feed;
        }
        else {
          // add 2nd day listings to the array
          $channels[$feed['short_name']]['listings'] = array_merge($channels[$feed['short_name']]['listings'], $feed['listings']);
        }
      }

    }

    // increment a day
    $apidate = strtotime($thisday . ' +1 day');
  }

  if (!empty($channels)) {
  //Limit to just 3 episodes for just this channel
  $count = 0;
  $prev_episodes = array();
  $episodes = array();
  foreach ($channels[$channel]['listings'] as $i => $listing) {
    // stop after three good episodes
    if ($count == 3) {
      break;
    }
    $epstart = $listing['full_start'];

    if ($epstart < $start) {
      $prev_episodes[] = $listing;
    }
    elseif ($epstart >= $start) {
      $episodes[] = $listing;
      $count++;
    }
  }

  // If we're in the middle of an episode, grab the current episode and insert it into the array and bring the total eps back down to 3
  $first_start = $episodes[0]['full_start'];
  if ($first_start > $start) {
    $current_episode = array_pop($prev_episodes);
    array_unshift($episodes, $current_episode);
    $episodes = array_slice($episodes, 0, 3);
  }

  // pretty things up
  $variables = array();
  $delta = 0;
  foreach ($episodes as $episode) {
    // figure out index
    $ep_id = pbs_tvapi_getindex($episode);


    // set title variable
    if (!empty($ep_id) && isset($series[$ep_id])) {
      $title = l($episode['title'], 'node/' . $series[$ep_id]);
    }
    else {
      $title = $episode['title'];
    }
    $variables[$delta]['title'] = $title;

    // set episode title variable
    $eptitle = '';
    if (isset($episode['episode_title']) && !empty($episode['episode_title'])) {
      $eptitle = $episode['episode_title'];
    }
    //
    $variables[$delta]['eptitle'] = $eptitle;

    // set start time variable
    $variables[$delta]['starttime'] = date('g:iA', $episode['full_start']);

    // increase the delta
    $delta++;

  }

  return theme('widget_list', array('episodes' => $variables));
  }

}
/*
 * What's On Now widget for Kids section
 *
 * Expects a feed ID to determine the channel
 */
function pbs_tvapi_onnow_kids($channel) {

  // Get YouTube Promo ids and put them in an array for later use
  $promos = pbs_tvapi_get_promos();

  // Get series information from db and put them in an array for later use
  $series = pbs_tvapi_get_series();

  $date = date('Y-m-d', time());
  $hour = date('H', time());

  $start = time();

  $method = 'day';
  $apidate = $start;

  $channels = '';
  // loop through two days worth of schedule to get a full 24 hours
  for ($days = 1; $days <= 2; $days++) {
    // pick a day
    $thisday = date('Ymd', $apidate);

    $scheduledata = pbs_tvapi_call2($method, $thisday);

    // loop through the response
    foreach ($scheduledata['feeds'] as $i => $feed) {

      if (!empty($feed['digital_channel'])) {
          foreach ($feed['listings'] as $n => $listing) {
            // add a full date to the array
            $fullstart = strtotime($thisday . ' ' . $listing['start_time']);
            $fullstart_human = date('Y-m-d g:i a', $fullstart);
            $feed['listings'][$n]['full_start'] = $fullstart;
          }

        if (empty($channels[$feed['short_name']])) {
          $channels[$feed['short_name']] = $feed;
        }
        else {
          // add 2nd day listings to the array
          $channels[$feed['short_name']]['listings'] = array_merge($channels[$feed['short_name']]['listings'], $feed['listings']);
        }
      }

    }

    // increment a day
    $apidate = strtotime($thisday . ' +1 day');
  }

  if (!empty($channels)) {
  //Limit to just 3 episodes for just this channel
  $count = 0;
  $prev_episodes = array();
  $episodes = array();
  foreach ($channels[$channel]['listings'] as $i => $listing) {
    // stop after three good episodes
    if ($count == 3) {
      break;
    }
    $epstart = $listing['full_start'];

    if ($epstart < $start) {
      $prev_episodes[] = $listing;
    }
    elseif ($epstart >= $start) {
      $episodes[] = $listing;
      $count++;
    }
  }

  // If we're in the middle of an episode, grab the current episode and insert it into the array and bring the total eps back down to 3
  $first_start = $episodes[0]['full_start'];
  if ($first_start > $start) {
    $current_episode = array_pop($prev_episodes);
    array_unshift($episodes, $current_episode);
    $episodes = array_slice($episodes, 0, 3);
  }

    // pretty things up
    $variables = array();
    $note = NULL;
    if ($channel == 'WETADT4') {
      $note = 'WETA TV 26 airs kids programming in the mornings.';
    }
    $delta = 0;
    foreach ($episodes as $episode) {
      // figure out index
      $ep_id = pbs_tvapi_getindex($episode);

      // set title variable
      if (isset($series[$ep_id])) {
        $title = l($episode['title'], 'node/' . $series[$ep_id]);
        $series_node = node_load($series[$ep_id]);
        if (!empty($series_node->field_kids_image)) {
          // prepare series image, if it exists
          unset($img_vars);
          if (isset($series_node->field_kids_image)) {
            $img_vars = array(
              'style_name' => 'kids_crop',
              'path' => $series_node->field_kids_image['und'][0]['uri'],
              'alt' => strip_tags($episode['title']),
              'width' => '',
              'height' => '',
              'attributes' => array(
                'class' => 'fltlt',
              ),
            );
          }

          $variables[$delta]['kids_image'] = theme_image_style($img_vars);
        }
      }
      else {
        $title = $episode['title'];
      }
      $variables[$delta]['title'] = $title;

      // set episode title variable
      $eptitle = '';
      if (isset($episode['episode_title']) && !empty($episode['episode_title'])) {
        $eptitle = $episode['episode_title'];
      }
      //
      $variables[$delta]['eptitle'] = $eptitle;

      // set start time variable
      $variables[$delta]['starttime'] = date('g:iA', $episode['full_start']);

      // increase the delta
      $delta++;

  }

  return theme('widget_list_kids', array('episodes' => $variables, 'fullsched' => TRUE, 'note' => $note));
  }
}


/*
 * What's On Tonight widget
 *
 * Expects a feed ID to determine the channel
 */
function pbs_tvapi_ontonight($channel) {

  // Get YouTube Promo ids and put them in an array for later use
  $promos = pbs_tvapi_get_promos();

  // Get series information from db and put them in an array for later use
  $series = pbs_tvapi_get_series();


  // set the start and end times for primetime
  $date = date('Y-m-d', time());
  $start = strtotime(date('Y-m-d', time()) . 'T20:00:00');
  $end = strtotime(date('Y-m-d', time()) . 'T23:00:00');

  $channels = pbs_tvapi_gettoday();

  //Limit to just 4 episodes, if necessary
  $count = 0;
  $episodes = array();
  foreach ($channels[$channel]['listings'] as $i => $listing) {
    if ($count == 4) {
      break;
    }
    $epstart = strtotime($date . ' ' . $listing['start_time']);
    $listing['full_start'] = $epstart;
    if ($epstart >= $start && $epstart <= $end) {
      $episodes[] = $listing;
      $count++;
    }
  }

  // pretty things up
  $variables = array();
  $delta = 0;
  foreach ($episodes as $episode) {
    // figure out index
    $ep_id = pbs_tvapi_getindex($episode);

    // set title variable
    if (!empty($ep_id) && isset($series[$ep_id])) {
      $title = l($episode['title'], 'node/' . $series[$ep_id]);
    }
    else {
      $title = $episode['title'];
    }
    $variables[$delta]['title'] = $title;

    // set episode title variable
    $eptitle = '';
    if (isset($episode['episode_title']) && !empty($episode['episode_title'])) {
      $eptitle = $episode['episode_title'];
    }
    //
    $variables[$delta]['eptitle'] = $eptitle;

    // set start time variable
    $variables[$delta]['starttime'] = date('g:iA', $episode['full_start']);


    // increase the delta
    $delta++;

  }

  return theme('widget_list', array('episodes' => $variables));
}

/*
 * Grid for schedule flyout
 */
function pbs_tvapi_on_now_grid($channel = 'all') {
  $series = pbs_tvapi_series();
  $date = date('Ymd', time());
  $time = date('H', time());

  // determine if we're in Daylight Savings and set offset accordingly
  $offset = '05:00';
  $offset_seconds = 18000;
  $dst = date('I');
  if ($dst == 1) {
    $offset = '04:00';
    $offset_seconds = 14400;
  }

    // set the start and end times
  $hour = $time . ':00:00-' . $offset;
  $start = strtotime(date('Y-m-d', strtotime($date)) . 'T' . $hour);
  // end 4 hours later.
  $end = $start + 14400;
  // get the feeds
  $channels = pbs_tvapi_geteps_allfeeds();

  // cycle through the feeds and only keep the episode information
  // relevant to this grid display
  if (!empty($channels)) {
  foreach ($channels as $i => $channel) {
    $filtered_episodes = array();
    if (!empty($channel['episodes'])) {
      foreach ($channel['episodes'] as $n => $episode) {
        $epstart = strtotime($episode['pbs_start_time']) - $offset_seconds;
        if ($epstart >= $start && $epstart < $end) {
          $filtered_episodes[] = $episode;
        }
      }
    }
    $channels[$i]['episodes'] = $filtered_episodes;
  }

  return theme('schedule_flyout', array('vars' => $channels, 'date' => $date, 'time' => $time, 'series' => $series));
  }
}

/*
 * What's On Now dropdowns for subnavs
 *
 * Expects an array of channel ids.
 */
function pbs_tvapi_on_now_dropdown($feeds) {
/*
  // set the start time
  $start = time();
  $date = date('Y-m-d', time());

  // get series
  $series = pbs_tvapi_get_series();

  $channels = pbs_tvapi_gettoday();

  if (!empty($channels)) {

    // cycle through the episodes and only keep the information for the current episode
    $current_eps = array();
    foreach ($feeds as $i => $feed_id) {

      foreach ($channels[$feed_id]['listings'] as $i => $listing) {
        $epstart = strtotime($date . ' ' . $listing['start_time']);
        $listing['full_start'] = $epstart;

        if ($epstart <= $start) {
          $prev_episodes[] = $listing;
        }
        elseif ($epstart > $start) {
          break;
        }
      }
      $current_ep =  array_pop($prev_episodes);
      $ep_id = pbs_tvapi_getindex($current_ep);
      $nid = $series[$ep_id];
      $current_eps[$i]['episode'] = $current_ep;
      $current_eps[$i]['episode']['nid'] = $nid;

    }

    return theme('schedule_dropdown', array('vars' => $current_eps));
  }
  */

  // removed all processing for performance reasons
  return theme('schedule_dropdown');

}

/**
 * END WHAT'S ON FUNCTIONS
 */


/**
 * BEGIN BY SERIES FUNCTIONS
 */

/**
 * Find upcoming episodes by series
 * $nid = node id
 */
function pbs_tvapi_upcomingbyseries($nid) {
// add node object to static cache
  $node = &drupal_static(__FUNCTION__);
  if (!isset($node)) {
    $node = node_load($nid);
  }

  // get promos
  // TODO: Move to promos module
  $promos = pbs_tvapi_get_promos();

  // check for whether this is a program or a one-off
  if (isset($node->field_program_id) && !empty($node->field_program_id)) {
    $method = 'upcoming/program';
    $pid = field_get_items('node', $node, 'field_program_id');
    $pid = field_view_value('node', $node, 'field_program_id', $pid[0]);
    $pid = str_replace(' ', '', $pid);
    $param = drupal_render($pid);
  }
  elseif (isset($node->field_show_id) && !empty($node->field_show_id)) {
    $method = 'upcoming/show';
    $sid = field_get_items('node', $node, 'field_show_id');
    $sid = field_view_value('node', $node, 'field_show_id', $sid[0]);
    $sid = str_replace(' ', '', $sid);
    $param = drupal_render($sid);
  }

  $scheduledata = pbs_tvapi_call2($method, $param);

  // must normalize results since API isn't consistent in its naming schemes
  $upcoming = array();
  if (isset($scheduledata['upcoming_episodes'])) {
    $upcoming = $scheduledata['upcoming_episodes'];
  }
  elseif (isset($scheduledata['upcoming_shows'])) {
    $upcoming = $scheduledata['upcoming_shows'];
  }

  $filtered_episodes = array();

  // we only want the digital channels
  foreach ($upcoming as $i => $episode) {
    if (!empty($episode['feed']['digital_channel'])) {

      // get associated promo
      // TODO: Move to promos module
      $episode['promo'] = NULL;
      $promo_key = pbs_tvapi_getindex($episode);
      if (empty($promo_key) && isset($node->field_show_id) && !empty($node->field_show_id)) {
        $episode_id = field_get_items('node', $node, 'field_show_id');
        $episode_id = field_view_value('node', $node, 'field_show_id', $episode_id[0]);
        $promo_key = drupal_render($episode_id);
      }

      if (!empty($promo_key) && !empty($promos[$promo_key])) {
        $promo_id = $promos[$promo_key];
        $icon = '<img src="' . base_path() . drupal_get_path('theme', $GLOBALS['theme']) . '/templates/images/vid-icon.png" alt="" />';
        $vid_icon = l($icon, 'http://www.youtube.com/watch', array('attributes' => array('class' => array('video_preview')), 'html' => TRUE, 'query' => array('v' => $promo_id)));
        $episode['promo'] = $vid_icon;
      }

      // end promos

      // date and time information
      $start = strtotime($episode['day'] . ' ' . $episode['start_time']);
      $episode['date_formatted'] = date('D., F j, Y', $start);
      $episode['time_formatted'] = date('g:i a', $start);

      // if no episode title, display the show title
      if (empty($episode['episode_title'])) {
        $episode['episode_title'] = $node->title;
      }

      // if no episode description, display the show description
      if (empty($episode['episode_description']) && isset($node->field_description) && !empty($node->field_description)) {
        $description = field_get_items('node', $node, 'field_description');
        $description = field_view_value('node', $node, 'field_description', $description[0]);
        $episode['episode_description'] = drupal_render($description);
      }

      $filtered_episodes[] = $episode;
    }
  }

  if (isset($filtered_episodes) && !empty($filtered_episodes)) {
    $initial_display = 5;
    $variables = array('episodes' => $filtered_episodes, 'initial_display' => $initial_display);
    return theme_episode_grid($variables);
  }
  else {
    $no_results = module_invoke('pbs_tvapi', 'block_view', 'upcoming_noresults');
    return render($no_results['content']);
  }

}

/**
 * END BY SERIES FUNCTIONS
 */

/**
 * AJAX widget to find episode ids by series
 *
 * On submit, the markup in the #markup element is updated.
 */
function pbs_tvapi_get_episode_ids($form, &$form_state) {

  $form['series_complete'] = array(
    '#type' => 'textfield',
    '#title' => t('Select a series:'),
    '#autocomplete_path' => 'tvseries/autocomplete',
  );
  $form['box'] = array(
    '#type' => 'markup',
    '#prefix' => '<div id="box">',
    '#suffix' => '</div>',
    '#markup' => '',
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#ajax' => array(
      'callback' => 'pbs_tvapi_submit_driven_callback',
      'wrapper' => 'box',
      'name' => 'submit1',
    ),
    '#value' => t('Get episodes'),
  );

  return $form;
}

/**
 * Select the 'box' element, change the markup in it, and return it as a
 * renderable array.
 *
 * @return renderable array (the box element)
 */
function pbs_tvapi_submit_driven_callback($form, $form_state) {

  // Get the input from the form and extract the NID
  $series = explode('[nid: ', $form_state['values']['series_complete']);
  $series = explode(']', $series[1]);
  $series = $series[0];
  $output = '';
  // safety first
  if (is_numeric($series)) {

    // load the series node
    $node = node_load($series);

    // initialize array to hold the episode results
    $ep_ids = array();

    // programs and shows use different methods to get upcoming episodes
    if (!empty($node->field_program_id['und'][0]['value'])) {
      $method = 'upcoming/program';
      $params = $node->field_program_id['und'][0]['value'];

      $scheduledata = pbs_tvapi_call2($method, $params);

      // pull the episode ids and titles into the results array
      foreach ($scheduledata['upcoming_episodes'] as $i => $episode) {
        // get airdate dates
        $airdate = date('m/d/Y g:i a', strtotime($episode['day'] . ' ' . $episode['start_time']));

        $ep_ids[$episode['show_id']] = $episode['show_id'] . ' (' . $episode['episode_title'] . ' &mdash; ' . $airdate . ' on ' . $episode['feed']['full_name'] . ')';
      }
    }
    elseif (!empty($node->field_show_id['und'][0]['value'])) {
      $method = 'upcoming/show';
      $params = $node->field_show_id['und'][0]['value'];

      $scheduledata = pbs_tvapi_call2($method, $params);

      // pull the episode ids and titles into the results array
      foreach ($scheduledata['upcoming_shows'] as $i => $episode) {
        // get airdate dates
        $airdate = date('m/d/Y g:i a', strtotime($episode['day'] . ' ' . $episode['start_time']));
        $ep_ids[$params] = $params . ' (' . $node->title . ' &mdash; ' . $airdate . ' on ' . $episode['feed']['full_name'] . ')';
      }
    }

    // make sure we have results
    if (count($ep_ids) > 0) {

      // set up the results list
      $variables = array(
        'items' => $ep_ids,
        'title' => 'Episode IDs',
        'type' => 'ul',
        'attributes' => array(),
      );

      // theme it
      $output = theme_item_list($variables);

    }
    else {

      // if no results
      $output = '<p>This series is not currently in the schedule.</p>';

    }

  // if the NID is not numeric, display an error message
  }
  else {
    $output = '<p>Whoops!  Something went wrong.  Please pick another series.</p>';
  }

  // alter the form to display the results
  $element = $form['box'];
  $element['#markup'] = $output;

  return $element;
}

/**
 * autocomplete helper for episode id search
 * $string = string for search
 */
function pbs_tvapi_tvseries_autocomplete($string = '') {
  $matches = array();

  // searching in database
  if ($string) {

    // the query
    $result = db_select('node')
      ->fields('node', array('title', 'nid'))
      ->condition(db_and()
      ->condition('type', 'tv_series')
      ->condition('title', '%' . db_like($string) . '%', 'LIKE'))
      ->range(0, 10)
      ->execute();



    // insert query results into the $matches array

    foreach ($result as $record) {
      $matches[$record->title . '[nid: ' . $record->nid . ']'] = check_plain($record->title);
    }
  }

  // output the results to the user
  drupal_json_output($matches);

}

/**
 * Database query to get all the episode ids and youtube ids
 * to match against tv schedule data
 *
 * @params
 *  - $eid = episode id
 *  - $type = content type
 *
 * Pulls data from the 'youtube_promos' content type
 *
 * TODO: DELETE ONCE MOVE TO PROMOS MODULE IS COMPLETE!!!
 */
function pbs_tvapi_get_promos($type = 'youtube_promos') {
  $promos = &drupal_static(__FUNCTION__);
  if (!isset($promos)) {
    if ($cache = cache_get('pbs_tvapi_getpromos_data')) {
      $promos = $cache->data;
    }
    else {
      // Get promo information from db
      $result = db_query('SELECT n.nid, y.field_youtube_id_value, e.field_episode_id_value FROM {node} n LEFT JOIN {field_data_field_youtube_id} y ON n.nid = y.entity_id LEFT JOIN {field_data_field_episode_id} e ON n.nid = e.entity_id WHERE n.type = :type', array(':type' => $type));

      // build promos array
      $promos = array();
      foreach ($result as $record) {
        $promos[$record->field_episode_id_value] = $record->field_youtube_id_value;
      }
      cache_set('pbs_tvapi_getpromos_data', $promos, 'cache', CACHE_TEMPORARY);
    }
  }
  return $promos;
}



/**
 * END PBS / YOUTUBE API BRIDGE FUNCTIONS
 */

